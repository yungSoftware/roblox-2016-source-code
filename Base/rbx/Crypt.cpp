#if defined(_WIN32) && !defined(RBX_PLATFORM_DURANGO)
#include "rbx/Crypt.h"

#include "rbxFormat.h"
#include <atlenc.h>
#include <iomanip>
#include <sstream>

#include "rbx/Debug.h"

namespace RBX {

Crypt::Crypt()
{
	static const char* keyB64 = "BgIAAACkAABSU0ExAAQAAAEAAQBBr7Zn+QHfNgsZEe7fU2JZGWZPJC37AUU7+wSXLTbZBdwlHJjDDAB0qT2s3OZsbJgP2TZkv/JkLBWwcPVXvDG4UdRmH3/L9fG8I6pdY7YJLWK6aXn4cUP2Fx4srYsr6w/hK9eHA5yx2T+5HocRtFI46qlnUIveGUyT0VlD9PxHtw==";
	char pbKeyBlob[256];
	int dwBlobLen = 256;

	// http://support.microsoft.com/kb/238187
	if (!CryptAcquireContext(&context, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
	{
		if (::GetLastError()==NTE_BAD_KEYSET)
		{
			if (!CryptAcquireContext(&context, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_NEWKEYSET))
				throw RBX::runtime_error("Error %x during CryptAcquireContext 2\n", GetLastError());
		}
		else
			throw RBX::runtime_error("Error %x during CryptAcquireContext\n", GetLastError());
	}

	
	{		
		ATL::Base64Decode(keyB64, strlen(keyB64), (BYTE*)pbKeyBlob, &dwBlobLen);
	}

	if (!CryptImportKey(context, (BYTE*)pbKeyBlob, dwBlobLen, 0, 0, &key))
		 throw RBX::runtime_error("Error %x during CryptImportKey", GetLastError());
}

Crypt::~Crypt()
{
	CryptDestroyKey(key);
	CryptReleaseContext(context, 0);
}

bool Crypt::verifySignatureBase64(std::string message, std::string signatureBase64, ALG_ID hashAlgorithm)
{
	HCRYPTHASH hash;
	if (!CryptCreateHash(context, hashAlgorithm, NULL, 0, &hash))
#ifdef _DEBUG
		 throw RBX::runtime_error("Error %x during CryptCreateHash", GetLastError());
#else
		 throw RBX::runtime_error("");
#endif
	
	bool result = false;
	
	try
	{
		if (!CryptHashData(hash, (BYTE*)message.c_str(), message.size(), 0))
#ifdef _DEBUG
			throw RBX::runtime_error("Error %x during CryptHashData", GetLastError());
#else
			throw RBX::runtime_error("");
#endif
		
		int signatureLen = Base64DecodeGetRequiredLength(signatureBase64.size());
		BYTE* signature = (BYTE*)alloca(signatureLen);
		ATL::Base64Decode(signatureBase64.c_str(), signatureBase64.size(), signature, &signatureLen);
		
		/*
			The native cryptography API uses little-endian byte order 
			while the .NET Framework API uses big-endian byte order. 
			If you are verifying a signature generated by using a .NET Framework 
			API, you must swap the order of signature bytes before calling the 
			CryptVerifySignature function to verify the signature.
		*/
		BYTE* signatureRev = (BYTE*)alloca(signatureLen);
		for (int i = 0; i < signatureLen; ++i)
			signatureRev[i] = signature[signatureLen - i - 1];

#pragma warning(push)
#pragma warning(disable: 6309)
#pragma warning(disable: 6387)
		result = CryptVerifySignature(hash, signatureRev, signatureLen, key, NULL, 0) != 0;
		if (!result) {
#ifdef _DEBUG
			RBX::StandardOut::singleton()->printf(RBX::MESSAGE_ERROR, 
				"CryptVerifySignature Error 0x%x. sigLen=%d sigB64='%s' message='%s'", 
				GetLastError(), signatureLen, signatureBase64.c_str(), message.c_str());
#endif
		}
#pragma warning(pop)
	}
	catch (...)
	{
		::CryptDestroyHash(hash);
		throw;
	}

	::CryptDestroyHash(hash);
	return result;
}

void Crypt::verifySignatureBase64(std::string message, std::string signatureBase64)
{
	if (!verifySignatureBase64(message, signatureBase64, CALG_SHA_256))
	{
		if (!verifySignatureBase64(message, signatureBase64, CALG_SHA1))
		{
#ifdef _DEBUG
			throw RBX::runtime_error("Signature verification failed with both SHA-256 and SHA-1");
#else
			throw RBX::runtime_error("");
#endif
		}
	}
}

} //namespace RBX

#else

#include "rbx/Crypt.h"

namespace RBX
{

Crypt::Crypt() {}
Crypt::~Crypt() {}
void Crypt::verifySignatureBase64(std::string message, std::string signatureBase64) {}
bool Crypt::verifySignatureBase64(std::string message, std::string signatureBase64, ALG_ID hashAlgorithm) { return true; }

}

#endif
